// Generated by CoffeeScript 2.3.2
(function() {
  var moment, mqtt_match, to_mqtt_payload, to_mqtt_topic;

  moment = require('moment-timezone');

  mqtt_match = function(pattern, topic) {
    var regex;
    regex = pattern.replace(/\+/g, "[^/]*").replace(/\/#$/, "/.*");
    return topic.match("^" + regex + "$");
  };

  to_mqtt_topic = function(msg) {
    var digit, digits, geohash, headsign, i, mode, route, x, y;
    x = msg.position.latitude;
    y = msg.position.longitude;
    digit = function(x, i) {
      return "" + Math.floor(x * 10 ** i) % 10;
    };
    digits = (function() {
      var j, results;
      results = [];
      for (i = j = 1; j <= 3; i = ++j) {
        results.push(digit(x, i) + digit(y, i));
      }
      return results;
    })();
    geohash = Math.floor(x) + ";" + Math.floor(y) + "/" + digits.join('/');
    headsign = "XXX"; // not available from current sources
    return `/hfp/v1/journey/ongoing/${msg.vehicle.type}/${msg.vehicle.id}/${msg.vehicle.id}/${msg.trip.route}/${msg.trip.direction}/${headsign}/${msg.trip.start_time}/${msg.position.next_stop}/` + geohash;
  };

  to_mqtt_payload = function(msg) {
    var now, now_hour, oday, start_hour;
    now = moment().tz('Europe/Helsinki');
    // if there's start_time but no start_date, guess one
    if ((msg.trip.start_time != null) && (msg.trip.start_date == null)) {
      start_hour = parseInt(msg.trip.start_time.substring(0, 2));
      now_hour = now.hour();
      oday = moment().tz('Europe/Helsinki');
      if (start_hour > 16 && now_hour < 8) {
        // guess departure was yesterday instead of >8 hours in future
        oday.subtract(1, 'day');
      } else if (start_hour < 8 && now_hour > 16) {
        // guess departure is tomorrow instead of >8 hours ago
        oday.add(1, 'day');
      } else {
        oday = now;
      }
    } else {
      oday = void 0;
    }
    return {
      VP: {
        desi: msg.trip.route,
        dir: msg.trip.direction,
        oper: "XXX", // we don't have operator id yet
        veh: msg.vehicle.id,
        tst: moment(msg.timestamp * 1000).toISOString(),
        tsi: Math.floor(msg.timestamp),
        spd: Math.round(msg.position.speed * 100) / 100,
        hdg: msg.position.bearing,
        lat: msg.position.latitude,
        long: msg.position.longitude,
        dl: msg.position.delay,
        odo: msg.position.odometer,
        oday: msg.trip.start_day || (oday != null ? oday.format("YYYY-MM-DD") : void 0),
        jrn: "XXX", // we don't have departure id yet
        line: "XXX", // we don't have stop pattern id yet
        start: msg.trip.start_time,
        stop_index: msg.position.next_stop_index,
        source: msg.source
      }
    };
  };

  module.exports = {
    to_mqtt_topic: to_mqtt_topic,
    to_mqtt_payload: to_mqtt_payload,
    mqtt_match: mqtt_match
  };

}).call(this);
